# SQL guide: Getting started

**Structured Query Language** (or **SQL**, often pronounced “sequel”) enables data analysts to talk to their databases. SQL is one of the most useful data analyst tools, especially when working with large datasets in tables. It can help you investigate huge databases, track down text (referred to as strings) and numbers, and filter for the exact kind of data you need—much faster than a spreadsheet can.

## What is a query?

A **query** is a request for data or information from a database. When you query databases, you use SQL to communicate your question or request. You and the database can always exchange information as long as you speak the same language.

Every programming language, including SQL, follows a unique set of guidelines known as **syntax**. Syntax is the predetermined structure of a language that includes all required words, symbols, and punctuation, as well as their proper placement. As soon as you enter your search criteria using the correct syntax, the query starts working to pull the data you’ve requested from the target database.

The syntax of every SQL query is the same:

- Use **SELECT** to choose the columns you want to return.
- Use **FROM** to choose the tables where the columns you want are located.
- Use **WHERE** to filter for certain information.

A SQL query is like filling in a template. You will find that if you are writing a SQL query from scratch, it is helpful to start a query by writing the SELECT, FROM, and WHERE keywords in the following format:

```sql
SELECT -- mention column name from which to retrieve data
FROM -- mention table name from which to retrieve data
WHERE -- mention criteria that the data must meet

```

Make sure to add a new line and indent when adding these, as shown below:

Following this method each time makes it easier to write SQL queries. It can also help you make fewer syntax errors.

### **Example of a query**

```sql
SELECT first_name
FROM customer_data.customer_name
WHERE first_name = 'Tony'
```

The results from the query might be similar to the following:


| first_name |
| ------------ |
| Tony       |
| Tony       |
| Tony       |

### Multiple columns in a query with SELECT

```sql
SELECT
	customer_id,
	first_name,
	last_name
FROM
	customer_data.customer_name
WHERE
	first_name = 'Tony'
```

The results from the query might be similar to the following:


| customer_id | first_name | last_name |
| ------------- | ------------ | ----------- |
| 1967        | Tony       | Magnolia  |

### Multiple columns in a query with WHERE

```sql
SELECT
	customer_id,
	first_name,
	last_name
FROM
	customer_data.customer_name
WHERE
	customer_id > 0
	AND first_name = 'Tony'
	AND last_name = 'Magnolia'
```

The results from the query might be similar to the following:


| customer_id | first_name | last_name |
| ------------- | ------------ | ----------- |
| 1967        | Tony       | Magnolia  |
| 7689        | Tony       | Magnolia  |

# Endless SQL possibilities

You have learned that a SQL query uses SELECT, FROM, and WHERE to specify the data to be returned from the query. This reading provides more detailed information about formatting queries, using WHERE conditions, selecting all columns in a table, adding comments, and using aliases. All of these make it easier for you to understand (and write) queries to put SQL in action. The last section of this reading provides an example of what a data analyst would do to pull employee data for a project.

## Capitalization, indentation, and semicolons

You can write your SQL queries in all lowercase and don’t have to worry about extra spaces between words. However, using capitalization and indentation can help you read the information more easily. Keep your queries neat, and they will be easier to review or troubleshoot if you need to check them later on.

```sql
SELECT field1
FROM table
WHERE field1 = condition;
```

Notice that the SQL statement shown above has a semicolon at the end. The semicolon is a statement terminator and is part of the American National Standards Institute (ANSI) SQL-92 standard, which is a recommended common syntax for adoption by all SQL databases. However, not all SQL databases have adopted or enforce the semicolon, so it’s possible you may come across some SQL statements that aren’t terminated with a semicolon. If a statement works without a semicolon, it’s fine.

## WHERE conditions

In the query shown above, the SELECT clause identifies the column you want to pull data from by name, field1, and the FROM clause identifies the table where the column is located by name, table. Finally, the WHERE clause narrows your query so that the database returns only the data with an exact value match or the data that matches a certain condition that you want to satisfy.

For example, if you are looking for a specific customer with the last name Chavez, the WHERE clause would be:

WHERE field1 = 'Chavez'

However, if you are looking for all customers with a last name that begins with the letters “Ch," the WHERE clause would be:

WHERE field1 LIKE 'Ch%'

You can conclude that the LIKE clause is very powerful because it allows you to tell the database to look for a certain pattern! The percent sign % is used as a wildcard to match one or more characters. In the example above, both **Chavez** and **Chen** would be returned. Note that in some databases an asterisk * is used as the wildcard instead of a percent sign %.

## SELECT all columns

Can you use  SELECT * ?

In the example, if you replace SELECT field1 with SELECT * , you would be selecting all of the columns in the table instead of the field1 column only. From a syntax point of view, it is a correct SQL statement, but you should use the asterisk * sparingly and with caution.  Depending on how many columns a table has, you could be selecting a tremendous amount of data. Selecting too much data can cause a query to run slowly.

## Comments

Some tables aren’t designed with descriptive enough naming conventions. In the example, field1 was the column for a customer’s last name, but you wouldn’t know it by the name. A better name would have been something such as last_name. In these cases, you can place comments alongside your SQL to help you remember what the name represents. Comments are text placed between certain characters, /* and */, or after two dashes --) as shown below.

```sql
SELECT
	field1 /* this is the last name column */
FROM
	table -- this is the customer data table  
WHERE
	field1 LIKE 'Ch%';
```

Comments can also be added outside of a statement as well as within a statement. You can use this flexibility to provide an overall description of what you are going to do, step-by-step notes about how you achieve it, and why you set different parameters/conditions.

```sql
-- This is an important query used later to join with the accounts table 
SELECT
 		rowkey,  -- key used to join with account_id
Info.date,  -- date is in string format YYYY-MM-DD HH:MM:SS
Info.code  -- e.g., 'pub-###'

FROM  Publishers
```

The more comfortable you get with SQL, the easier it will be to read and understand queries at a glance. Still, it never hurts to have comments in a query to remind yourself of what you’re trying to do. This also makes it easier for others to understand your query if your query is shared. As your queries become more and more complex, this practice will save you a lot of time and energy to understand complex queries you wrote months or years ago.

### **Example of a query with comments**

Here is an example of how comments could be written in BigQuery:

```sql
-- Pull basic information from the customer table
SELECT
	customer_id, --main ID used to join with customer_addresss
	first_name, --customer's first name from loyalty program
	last_name --customer's last name
FROM
	customer_data.customer_name
```

In the above example, a comment has been added before the SQL statement to explain what the query does. Additionally, a comment has been added next to each of the column names to describe the column and its use. Two dashes -- are generally supported. So it is best to use -- and be consistent with it. You can use # in place of -- in the above query, but # is not recognized in all SQL versions; for example, MySQL doesn’t recognize #.  You can also place comments between /* and */ if the database you are using supports it.

As you develop your skills professionally, depending on the SQL database you use, you can pick the appropriate comment delimiting symbols you prefer and stick with those as a consistent style. As your queries become more and more complex, the practice of adding helpful comments will save you a lot of time and energy to understand queries that you may have written months or years prior.

## Aliases

You can also make it easier on yourself by assigning a new name or **alias **to the column or table names to make them easier to work with (and avoid the need for comments). This is done with a SQL AS clause. In the example below, aliases are used for both a table name and a column. Within the database, the table is called actual_table_name and the column in that table is called actual_column_name. They are aliased as my_table_alias and my_column_alias, respectively.** **These aliases are good for the duration of the query only. An alias doesn’t change the actual name of a column or table in the database.

### **Example of a query with aliases**

```sql
SELECT 
	my_table_alias.actual_column_name AS my_column_alias
FROM
	actual_table_name AS my_table_alias

```

## Putting SQL to work as a data analyst

Imagine you are a data analyst for a small business and your manager asks you for some employee data. You decide to write a query with SQL to get what you need from the database.

You want to pull all the columns: **empID, firstName, lastName, jobCode,** and **salary. **Because you know the database isn’t that big, instead of entering each column name in the SELECT clause, you use SELECT *.  This will select all the columns from the Employee table in the FROM clause.

```sql
SELECT
	*
FROM
	Employee
```

Now, you can get more specific about the data you want from the **Employee **table. If you want all the data about employees working in the 'SFI' job code, you can use a WHERE clause to filter out the data based on this additional requirement.

Here, you use:

```sql
SELECT
	*
FROM
	Employee
WHERE
	jobCode = 'SFI'
```

A portion of the resulting data returned from the SQL query might look like this:


| **empID** | **firstName** | **lastName** | **jobCode** | **salary** |
| ----------- | --------------- | -------------- | ------------- | ------------ |
| 0002      | Homer         | Simpson      | SFI         | 15000      |
| 0003      | Marge         | Simpson      | SFI         | 30000      |
| 0034      | Bart          | Simpson      | SFI         | 25000      |
| 0067      | Lisa          | Simpson      | SFI         | 38000      |
| 0088      | Ned           | Flanders     | SFI         | 42000      |
| 0076      | Barney        | Gumble       | SFI         | 32000      |

Suppose you notice a large salary range for the 'SFI' job code. You might like to flag all employees in all departments with lower salaries for your manager. Because interns are also included in the table and they have salaries less than $30,000, you want to make sure your results give you only the full time employees with salaries that are $30,000 or less. In other words, you want to exclude interns with the 'INT' job code who also earn less than $30,000. The AND clause enables you to test for both conditions.

You create a SQL query similar to below, where <> means "does not equal":

```sql
SELECT
	*
FROM
	Employee
WHERE
	jobCode <> 'INT' 
      AND salary <= 30000;
```

The resulting data from the SQL query might look like the following (interns with the job code **INT** aren't returned):


| **empID** | **firstName** | **lastName** | **jobCode** | **salary** |
| ----------- | --------------- | -------------- | ------------- | ------------ |
| 0002      | Homer         | Simpson      | SFI         | 15000      |
| 0003      | Marge         | Simpson      | SFI         | 30000      |
| 0034      | Bart          | Simpson      | SFI         | 25000      |
| 0108      | Edna          | Krabappel    | TUL         | 18000      |
| 0099      | Moe           | Szyslak      | ANA         | 28000      |

With quick access to this kind of data using SQL, you can provide your manager with tons of different insights about employee data, including whether employee salaries across the business are equitable. Fortunately, the query shows only an additional two employees might need a salary adjustment and you share the results with your manager.

Pulling the data, analyzing it, and implementing a solution might ultimately help improve employee satisfaction and loyalty. That makes SQL a pretty powerful tool.
